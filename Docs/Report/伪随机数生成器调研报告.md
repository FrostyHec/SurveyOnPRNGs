姓名：黄政东<br />学号：12212230

---

<a name="k21E4"></a>
# 摘要
现如今，由于对可靠随机序列需要，随机数生成器受到了广泛的应用于发展。本报告尝试对现有的随机数生成器进行调查研究，尝试阐述随机数概念的基本定义与类别，总结现有的伪随机数生成器评价方法并对其原理进行分析。同时，报告阐述了常见的伪随机数生成算法，并对常见的算法进行了理论分析与java代码实现，同时使用NIST随机数生成器检测工具对生成序列进行评估。随后，报告总结了现有主流语言与操作系统的随机数生成器实现，同时尝试使用数学理论对LCG算法及java Random类进行了攻击尝试。最后，报告总结了现有伪随机数的应用常见，并对伪随机数生成器的发展做出展望。本报告附件中包含了测试过程的原始数据、报告处理脚本与基于Java的部分伪随机数生成算法代码实现，并编写了统一的基准测试，该项目实现具备一定的可扩展性，开发者可以基于此项目较为方便地进行伪随机数生成器算法的开发与测试。
<a name="twIJf"></a>
# 正文
<a name="bEQqX"></a>
## 随机数的定义
在计算机科学中，随机数往往被分为真随机数与伪随机数两大类，其两者之间存在较为明确的划分界限。综合传统的划分方式，本报告为各类随机数做出如下定义与阐述。
<a name="HNsxd"></a>
### 真随机数
真随机数（True-random number, TRN），是指通过完全随机的物理过程而产生的完全随机的数字序列[2]，该数字序列服从一定范围内的均匀分布，且每一项数的选取与数列中的其他项无关。真随机数的生成依赖于可靠且充分随机的物理过程，在物理世界中，大气噪声，放射性衰变，电路热噪声等物理过程可以在现有的物理学理论下视为可靠的完全随机物理过程，而与此同时，宏观世界中较为常见的如抛掷骰子，用户敲击键盘等事件，由于其难以被完全精确地控制，事件具备一定的随机性与不可预测性，因此可以在特定条件下被视为可靠的完全随机物理过程。
<a name="vfXp3"></a>
### 伪随机数
伪随机数（pseudo-random number, PRN），是指通过一系列特定数学算法所生成的，满足统计学意义上的随机性质的数字序列[2]。相较于真随机数，伪随机数的最大特点在于其数字序列具有较强的确定性，如对于采用种子生成法所生成的伪随机数序列，当算法的初始种子确定时，该算法所生成的随机数序列可被完全确定。现有的共识认为，由于数学算法所具备的确定性，仅依赖于数学算法的随机数生成器只能生成伪随机数序列[4]，真随机数生成器的实现需要依赖于外部的物理过程。基于密码学安全理论，伪随机数又可分为强伪随机数与弱伪随机数， 三类随机数大致可通过以下性质进行划分：

| 类别 | 随机性 | 不可预测性 | 不可重现性 |
| --- | --- | --- | --- |
| 弱伪随机数 | √ | × | × |
| 强伪随机数 | √ | √ | × |
| 真随机数 | √ | √ | √ |

<a name="Rihw9"></a>
## 伪随机数生成器的评价方法
伪随机数生成器（pseudo-random number generator，PRNG），是一系列用于生成伪随机数的数学算法。现有的伪随机数生成器往往采用种子生成法：算法接收一个一段较短的，随机性良好的比特序列（种子）作为初值，在随后的迭代与运算过程中生成满足一定随机性质的比特序列（伪随机数）[1]。在伪随机数生成器的质量评估中，随机有效性与数列生成效率是两个重要的评价指标，可以作为衡量伪随机数生成器实用性的重要参考。
<a name="bx8VE"></a>
### 随机有效性
现有的划分体系将伪随机数生成器分为普通伪随机数生成器与密码学伪随机数生成器（Cryptographically secure pseudo-random number generator, CSPRNG）。依据德国联邦安全局所制订的BSI标准[3]，伪随机数生成器的安全性可以被分为如下四个等级：

- K1 - 产生的随机数序列彼此不同的概率应该是很高的
- K2 - 根据某些统计测试，无法分辨产生的序列和真随机序列。
- K3 - 给定任何子序列，任何攻击者都无法计算后续序列或者生成器的内部状态
- K4 - 给定生成器的内部状态，任何攻击者都无法计算之前的序列或者生成器之前的状态

上述等级中，满足K1等级的伪随机数生成器即可作为普通伪随机数生成器进行使用，而密码学安全级别的伪随机数生成器则需满足K3与K4标准，以提供更为安全可靠，具备对抗攻击性的随机数序列。同时，上述标准下的K1，K2标准往往可采用统计学方法进行验证，而K3，K4标准往往结合统计学与密码学理论工具进行验证或证明。
<a name="Rb3st"></a>
#### 普通PRNG有效性检验方法
普通PRNG有效性检验主要围绕随机数序列是否满足统计学意义上的随机序列性质，因此主要采用统计学方法进行检验。统计学检验方法包含了多种统计测试工具，通过分析随机数生成器所生成的极大量数字序列的统计学性质，统计学方法可以可度量地评价随机序列的均匀分布程度与各项独立程度。中国密码行业标准《随机性检测规范》[6]与美国国家标准与技术研究院 随机数生成测试方法[7]包含了用于测试生成器生成序列随机性的一系列测试方法，主要围绕序列频率，序列独立性，序列周期性等序列性质进行测试，本报告尝试阐述标准检测规范中常用的三种较为典型的随机性统计检测方法的检测过程并分析其背后的统计学原理。
<a name="dJ201"></a>
##### 期望测试
期望测试是最为经典的基于生成序列频率开展的随机性测试。该通过测试所生成的数字序列期望是否与相应的均匀分布期望相等以判断序列的随机性。以二进制数字序列为例，若为完全随机分布，序列中任意比特位的取值可视为离散型随机变量，其概率分布列如下所示<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705571547057-f88aa63a-24b4-4684-b5f3-0ac89a006b22.png#averageHue=%23f7f7f7&clientId=u8b8c7e80-324a-4&from=paste&height=114&id=uf7a7097a&originHeight=171&originWidth=472&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=5971&status=done&style=none&taskId=u6c9e2697-d695-4494-babe-0b28238ec12&title=&width=314.6666666666667)<br />依据离散型随机变量期望公式，0-1完全随机分布的期望如下所示<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705571657422-78451bcf-d807-40bb-9432-36c846b9c137.png#averageHue=%23f7f7f7&clientId=u8b8c7e80-324a-4&from=paste&height=83&id=u9fbad1a4&originHeight=125&originWidth=371&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=4241&status=done&style=none&taskId=u412b84ba-1a4a-40d0-ba5f-d8a702ea6e9&title=&width=247.33333333333334)<br />在实际应用中，可采用数学方法计算算法所生成的数列期望，以判断其是否通过期望测试。但采用数学方法往往较为困难，因此可采用数理统计工具，通过抽样结果进行检验。<br />对于随机数生成器所生成的0-1序列，若该序列各项服从0-1完全随机分布，则可将该序列作为总体 x 的一个样本，其性质满足以下规律<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705571630186-648600c3-4dd3-449c-987d-bd16ed33407a.png#averageHue=%23f6f6f6&clientId=u8b8c7e80-324a-4&from=paste&height=108&id=uc0af66bc&originHeight=162&originWidth=705&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=9596&status=done&style=none&taskId=u33f48ada-6518-4209-9f00-eab7170b9a5&title=&width=470)<br />由数理统计原理可知，当样本量充分大时，该随机序列的样本均值等于期望应等于总体期望[5]，其推导过程如下：<br />由辛钦大数定理，对于任意给定的实数ε>0，有<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705572829855-cad3c3a7-500a-4e8a-984a-6c8e4181f334.png#averageHue=%23f4f4f4&clientId=u8b8c7e80-324a-4&from=paste&height=71&id=K4nN5&originHeight=72&originWidth=266&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=4653&status=done&style=none&taskId=u242fc0b9-27fc-4b4b-bca9-c77e6ecc44f&title=&width=263.3333435058594)<br />因此可由期望公式得<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705572388809-9da27942-9778-485a-90a5-03bbdbd3b356.png#averageHue=%23f6f6f6&clientId=u8b8c7e80-324a-4&from=paste&height=89&id=u77e5615a&originHeight=134&originWidth=875&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=9878&status=done&style=none&taskId=uf717b0fd-968c-489d-90c3-7c059dc672d&title=&width=583.3333333333334)<br />因此，当样本量充分大时，可以通过判断所生成的二进制序列各项总体均值是否近似等于0.5以判断是否服从0-1完全随机分布。<br />由于随机性测试过程中，往往会生成较为庞大的随机序列，因此在实际应用可能会采用人工判断均值与期望的相近程度以决定是否存在非随机异常。参考假设检验的基本原理，本报告认为也可以采用二项检验的方式进行可量化的服从评估。二项检验可以较好的检验二元变量比例在一定置信水平下是否等于特定的假设值，其具体过程如下：

1. 确立原假设与备择假设

依据上述情况，我们设立如下的原假设（H0）与备择假设（H1）<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705583077374-e99d9672-d719-4e3d-aff3-143bae4667eb.png#averageHue=%23efefef&clientId=u8b8c7e80-324a-4&from=paste&height=61&id=uec263531&originHeight=91&originWidth=264&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=3869&status=done&style=none&taskId=ucd25747d-0f36-4316-80cd-b81ead1dae9&title=&width=176)

2. 确定显著性水平α

显著性水平α代表了在原假设正确的情况下拒绝原假设的概率，常选取0.05或0.01作为取值。

3. 计算检验统计量p值

由于备择假设为不等于随机，因此，可采用双尾检验法[8]计算其检验统计量p，可推得计算公式如下<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705583640962-0003bc54-4be5-4093-9aa6-92f008a5de31.png#averageHue=%23f5f5f5&clientId=u8b8c7e80-324a-4&from=paste&height=101&id=u8c54137d&originHeight=135&originWidth=854&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=11417&status=done&style=none&taskId=u5fa9d896-ad40-4c52-aac1-3a1d02ac706&title=&width=641.3333740234375)

4. 得出结论

将p值与显著性水平α进行比较，若p≤α，则推翻原假设，认为在该显著性水平下有足够证据证明随机数序列的期望与0-1完全随机分布期望不相等，反之则支持原假设，认定所生成的随机数序列通过了期望检验。<br />二项假设的优势在于其不依赖于正态分布近似，因此在选取样本量较小的条件下，仍可较为可靠的判断一定置信水平下的判断所生成的随机数序列是否满足0-1完全随机分布。

在现行的密码学规范中，往往采用单比特频数检测方法对随机数序列进行期望检测，单比特数检测法基于假设检验的原理进行测试，依赖于大样本量下的正态分布近似，其大致的检测流程与原理如下：

1. 将比特序列中的0,1分别转化为-1与1，即代入如下公式

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705585185785-ebe9be38-5675-4955-993f-55c539800c89.png#averageHue=%23f4f4f4&clientId=u5d60fae1-79d9-4&from=paste&height=45&id=u6f3ce7ee&originHeight=67&originWidth=532&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=4219&status=done&style=none&taskId=u8ea6a86a-79e1-46a2-89e1-b042fc9ba55&title=&width=354.6666666666667)

2. 计算测试统计量S

由于随机序列中每个比特的权重被视为一致，因此可采用直接求和的方式，计算该随机序列的测试统计量S，其公式如下<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705585735814-827d1e41-67da-47df-870e-03ea70cb3f03.png#averageHue=%23f4f4f4&clientId=u5d60fae1-79d9-4&from=paste&height=68&id=uf266c85a&originHeight=102&originWidth=284&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=3104&status=done&style=none&taskId=ucc51e311-5e7f-498e-8caf-defc6037ecb&title=&width=189.33333333333334)<br />若为严格地0-1随机分布，该顺序统计量S应当接近于0。随后，该测试方法通过正态分布近似进行进一步处理。

3. 计算P值并与显著性水平进行比较

在大样本量下，二项分布的分布曲线可近似为正态分布，因此，该测试方法采用标准正态分布中误差互补函数进行进一步处理，双尾测试下的p值可以通过如下公式求解<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705659098628-f2d124ac-e277-49f1-9ad7-9b79ae100ac4.png#averageHue=%23f1f1f1&clientId=u4b9ff6b1-0dc3-4&from=paste&height=68&id=ua1789c0c&originHeight=153&originWidth=292&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=5151&status=done&style=none&taskId=u26435992-a9f9-4773-9d89-3e1a90aa939&title=&width=129.6666717529297)<br />随后将p值与显著性水平α进行比较，若p≤α，则认为有足够证据表明该序列不满足0-1完全随机分布，反之则该随机数生成器通过单比特频数检测。<br />相较于本报告所提出的二项检验，单比特数检验依赖于正态分布近似，由于其避免了组合数的计算，计算效率可能更高，但该检测方法需要较大的随机数序列才能得到准确的生成结果。
<a name="vDXfv"></a>
##### 自相关测试
自相关检验用于检测生成序列各项之间的独立性程度。该测试通过比较逻辑左移特定位数后的新序列与原序列间的相似程度而检验所生成序列内部的自相关程度。对于理想的随机序列，逻辑左移后得到的新序列应与原序列具备较小的相似程度。<br />为运用统计学方法可度量地确定原序列与新序列间的关联程度，自相关测试往往采用对两序列按位异或的操作形成待测序列，随后检测待测序列是否可以通过期望测试，其大致检测流程与原理如下：

1. 通过将原序列与左移序列按位异或生成待测序列，并求出序列各项总和A(d)，其公式如下

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705659197126-aeff0977-76c6-4d99-bef8-be054b33651a.png#averageHue=%23f7f7f7&clientId=u4b9ff6b1-0dc3-4&from=paste&height=89&id=ue3936b9e&originHeight=134&originWidth=414&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=5355&status=done&style=none&taskId=u174f90fa-5182-4984-b7a5-c48b18098ab&title=&width=276)

2. 由上述分析可知，若两序列中不存在明显的相关性，则异或操作后的新序列亦服从0-1完全随机分布，而由期望测试可知，当样本量相当大时，该二项分布可近似为正态分布，各项和A(d)代表二项分布中的成功次数，依据数理统计原理，可以推导出服从标准正态分布的统计量形式，其推导如下

棣莫佛-拉普拉斯中心极限定理[5]讨论了二项分布下的随机变量序列的中心极限性质，其形式如下<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705658098687-c0d2d156-5fbb-4c4b-a354-f4150687cf27.png#averageHue=%23f1f0ef&clientId=u4b9ff6b1-0dc3-4&from=paste&height=102&id=u713d973b&originHeight=142&originWidth=556&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=22785&status=done&style=none&taskId=u06e1c880-e441-4cc8-811a-b7633eb5f5a&title=&width=399.66668701171875)<br />其中，{ηn}为服从参数为n,p的0-1二项分布的随机变量列，ηn代表随机变量列各项总和。<br />由上述公式可构造服从标准正态分布的统计量V，其形式如下<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705658994891-9ee5208b-9070-45b3-9a0b-2a9df555348f.png#averageHue=%23f1f1f1&clientId=u4b9ff6b1-0dc3-4&from=paste&height=106&id=ua9b7c6ee&originHeight=234&originWidth=1112&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=21299&status=done&style=none&taskId=u81831822-31ba-4740-b377-6016122ef95&title=&width=505.3333435058594)

3. 依据假设检验的方法对统计量V进行进一步处理，采用双尾检测形式下的误差概率计算公式求解其P值，其公式如下

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705659684901-5ca70c05-cb84-4e08-8d8d-5705f06ff044.png#averageHue=%23f5f5f5&clientId=u4b9ff6b1-0dc3-4&from=paste&height=79&id=ubcd6e42f&originHeight=118&originWidth=373&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=4818&status=done&style=none&taskId=u453c076c-bcd3-45e5-8e0b-56d38217270&title=&width=248.66666666666666)

4. 将求解p值与所设定的显著性水平α进行比较，若p≤α，则表明序列内部存在较为显著的相关性，无法通过自相关性检验，反之则测试通过。

自相关测试通过逻辑左移异或与期望测试的方式，能够有效检验生成序列内部各项间的相关性程度，同时具有期望测试所具备的计算较为简便的特点。
<a name="ldhWI"></a>
##### 离散傅里叶检测
离散傅里叶检验主要检测生成序列内部是否存在明显的周期性特征。离散傅里叶变换可以将离散的生成序列转换至频域，通过检测变换频谱图的尖峰高度判断是否存在明显的周期性特征。若该序列为完全随机序列，所得频谱图尖峰高度应低于某个门限值。该检测方法的大致流程与原理如下：

1. 将比特序列中的0,1分别转化为-1与1，得到新序列{An}，具体方程如下

![](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705585185785-ebe9be38-5675-4955-993f-55c539800c89.png#averageHue=%23f4f4f4&from=url&height=47&id=qoPII&originHeight=67&originWidth=532&originalType=binary&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&title=&width=375)

2. 对新序列进行傅里叶变换得到复数序列 {f0...fn-1} ，由于变换具有对称性，因此只需要检测前n/2项的尖峰高度是否低于门限值即可，故求解该序列前n/2项复数的模并记为新序列，其方程如下

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705665320395-840e391a-596e-4611-bb3a-5b95a4d796a1.png#averageHue=%23f7f7f7&clientId=u4b9ff6b1-0dc3-4&from=paste&height=72&id=uf6c8420a&originHeight=123&originWidth=719&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=8222&status=done&style=none&taskId=u536d0eeb-4401-41bd-8068-bce0247649a&title=&width=422.3333435058594)

3. 计算门限值T，并记录上述{Fn/2}序列中小于门限值T的项个数N1

门限值T定义为：对完全随机序列进行上述处理，则超过该门限值的尖峰数量与总数比例不超过β。由傅里叶变换可知，由于其模数实数部分与虚数部分均服从正态分布N(0,n/2)[9]，则可定义服从于自由度为2的卡方分布的统计量Y，即有<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705668574854-00f92b83-9a20-4a68-96bf-323a73ef87e9.png#averageHue=%23f7f7f7&clientId=u4b9ff6b1-0dc3-4&from=paste&height=81&id=u93064d16&originHeight=121&originWidth=600&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=7400&status=done&style=none&taskId=u63abafa3-3f6d-4b80-a276-6d02b29884d&title=&width=400)<br />定义统计量Z=Y/2，则由上述分布有<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705669463830-9de5168e-c8ca-4cab-b419-1e6dd1026e6a.png#averageHue=%23fafafa&clientId=u4b9ff6b1-0dc3-4&from=paste&height=110&id=uffefd4dc&originHeight=165&originWidth=478&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=5194&status=done&style=none&taskId=u62cbe8ba-0786-45bb-8ce4-99b8043c0db&title=&width=319)<br />故可求得T的表达式如下<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705669991552-4eb429c1-db92-4474-b1a4-32a973f7e4e0.png#averageHue=%23f3f3f3&clientId=u4b9ff6b1-0dc3-4&from=paste&height=59&id=brbTN&originHeight=89&originWidth=269&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=2427&status=done&style=none&taskId=u3ff4d2c9-20d9-42de-a6de-69e736c57f8&title=&width=179.33333333333334)<br />随机性测试标准中往往采用β=0.05为参数进行检验，在带入并求出门限值T后，统计{Fn/2}序列中小于门限值T的项个数，记为量N1

4. 计算标准正态分布统计量d

在美国国家标准与技术研究院 随机数生成测试方法中，由中心极限定理与二项分布正太近似所得到的正态分布统计量d的公式如下<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705670624337-5a47b784-4bc9-4c9c-a2db-cd11dfaf9e84.png#averageHue=%23f1f1f1&clientId=u4b9ff6b1-0dc3-4&from=paste&height=103&id=ub19acdc1&originHeight=155&originWidth=307&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=5280&status=done&style=none&taskId=u28cbdd27-a213-4ecc-a63d-76a71815320&title=&width=204.66666666666666)<br />然而，后续的研究证明该统计量并不能精确的被近似看作标准正态分布， Pareschi等人对此进行了更为精确的修正[11]，修正后的统计量公式如下，该公式亦被新版中国密码学标准所采纳<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705670463305-691aedd7-f4b8-4cad-802f-80738c61c59d.png#averageHue=%23f3f3f3&clientId=u4b9ff6b1-0dc3-4&from=paste&height=103&id=u31cb2657&originHeight=173&originWidth=357&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=6017&status=done&style=none&taskId=udd28f471-7b37-4942-b3bb-e88e5c3c7a2&title=&width=212)

5. 采用双尾检测形式下的误差概率计算公式求解P值，P值求解公式如下

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705671239174-de1d0fa4-2f92-4e5e-918c-36d7149b2dda.png#averageHue=%23f4f4f4&clientId=u4b9ff6b1-0dc3-4&from=paste&height=80&id=u7c825fe9&originHeight=137&originWidth=374&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=5714&status=done&style=none&taskId=u596b0886-e814-44ec-b3b7-0b729fe66c3&title=&width=217.03704833984375)<br />随后与显著性水平α进行比较，若p≤α，则表明序列内部存在较为显著的周期性，无法通过离散傅里叶检验，反之则测试通过。
<a name="KcBVg"></a>
##### 总结
普通PRNG有效性检验往往围绕完全随机数列的性质进行检验，在上述分析的三种有效性检验方法中，检验方法首先选取随机数列所具有的特殊性质（如0-1完全随机均匀分布），对伪随机数生成序列进行处理，并构造统计量以反应生成序列与完全随机序列的差异，随后采用抽样统计原理与二项分布正太近似等方式将该统计量转化为特定的标准分布，并求解其P值于显著性水平进行比较。<br />上述过程被广泛应用于各种随机性检验方法中，中国密码行业标准《随机性检测规范》中的多数检测方法均采用如上过程进行检验，该方法可以可量化地分析生成序列与完全随机序列的近似程度，并得出一定显著性水平下该伪随机数是否可近似视为完全随机序列的结论，可以有效评估伪随机数生成器的随机有效性。
<a name="yXBLG"></a>
#### CSPRNG检验方法
密码学安全的伪随机数生成器在普通伪随机数生成器标准下进一步要求生成器具备一定的抗攻击性，因此要求对其安全性进行进一步的检验。生成器安全性的检验可分为 基于密码学理论的安全性证明 与 基于统计学原理的安全性测试两类，本报告尝试对此进行阐述。
<a name="xrT2T"></a>
##### 基于密码学理论的安全性证明
由于CSPRNG往往是基于密码学理论而构造出的具备可靠安全性的随机数生成器，因此，设计者往往运用理论工具对生成算法进行严格地安全性证明。基于密码学理论所设计并证明的伪随机数生成器可主要分为以下两类
<a name="VQPpy"></a>
###### 基于密码学原语所设计的随机数生成器
该类伪随机数生成器往往采用基本密码学原语进行构建，如基于哈希函数的CSPRNG标准Hash_DRBG，基于块加密算法的CSPRNG标准CTR_DRBG，由于其基于成熟且有限条件下安全的密码学基础算法，开发者往往依赖密码学原语的安全性对伪随机数生成器安全性进行证明。
<a name="MiwUu"></a>
###### 基于数学难题的随机数生成器
该类伪随机数算法往往基于被公认的困难数学难题而设计，如基于大素数分解难题的Blum Blum Shub算法，基于离散对数难题的Blum–Micali算法，该类算法由于所基于数学问题在现有理论或计算机技术下不存在快速的求解算法，因而可以在一定条件下保证该算法的安全性。
<a name="oQ4AR"></a>
##### 基于统计学原理的安全性测试
基于统计学原理的安全性测试往往参考已有的伪随机数生成算法进行测试，其中最为经典的便是基于LFSR的线性复杂度测试，本报告将尝试以此为例阐述其原理
<a name="fc8Nv"></a>
###### 线性复杂度测试
线性复杂度测试采用Berlekamp-Massey算法，通过计算生成序列各子序列的最短线性递推式，而线性递推式则描绘了线性反馈移位寄存器（LFSR）的行为，对于完全随机序列，其各子序列的LFSR长度应该充分长，因此，较短的LFSR表明该序列与弱随机序列或非随机序列相似，因此可以用于检验其安全性，其大致过程与原理如下

1. 将待测序列划分为N个长度为m的非重叠子序列，舍弃多余的比特数，N与m的关系如下

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705682507799-27fc4f83-702e-4d08-b1b8-d64206b96e68.png#averageHue=%23f4f4f4&clientId=u4b9ff6b1-0dc3-4&from=paste&height=59&id=u237a0a80&originHeight=99&originWidth=222&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=2176&status=done&style=none&taskId=u55709163-4aba-4fdc-aaab-63020f2c050&title=&width=132.4444580078125)

2. 使用Berlekamp-Massey算法计算每一段子序列的线性复杂度Li, 其证明与求解过程大致如下[12]

线性递推式的定义为：对于给定的数列{an}与数列{rm},{rm}为{an}的线性递推式当且仅当满足如下性质<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705685341667-35166a3a-c20b-484f-8e8b-784bee1bb0c9.png#averageHue=%23f7f7f7&clientId=u4b9ff6b1-0dc3-4&from=paste&height=81&id=ub06224a3&originHeight=139&originWidth=721&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=7868&status=done&style=none&taskId=u8d5977e5-95c9-4021-86f0-092eddfe549&title=&width=420.0740966796875)<br />Berlekamp-Massey算法采用递归方法进行实现，假定先前过程已求得序列前i-1项的最短线性递推式为Rc={rm}，Rc的下标c为修改线性递推式的次数。考虑前i项序列的最短线性递推式：<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705684205295-9a23e1cd-88a4-438d-ab7b-2d6e3d4ff55a.png#averageHue=%23f6f6f6&clientId=u4b9ff6b1-0dc3-4&from=paste&height=84&id=u9d079e77&originHeight=147&originWidth=392&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=5100&status=done&style=none&taskId=u764faf46-5160-4c3d-ba25-75e506c4303&title=&width=223.37039184570312)<br />若Δ=0，则该序列也是前i项序列{ai}的最短线性递推数列<br />若Δ不为0，则对原Rc序列进行改造为Rc+1，修改过程如下<br />a. 初始情况：若c=0，则ai为序列中第一个非零数，则将R1置为含i个0的序列{0,0,...,0}即可<br />b. 递推情况：当c>0时，需构造零一线性递推式式R'，使得Rc+1=Rc+R'所得的Rc+1为{ai}的最短线性递推数列，则R'={r'm}需满足如下性质：<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705685411105-45d023bf-947c-4013-aad5-f9a64639c523.png#averageHue=%23f6f6f6&clientId=u4b9ff6b1-0dc3-4&from=paste&height=78&id=u96fdc3a5&originHeight=138&originWidth=585&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=6763&status=done&style=none&taskId=ud2230649-b1b8-4925-bdcb-82f49d39624&title=&width=332.3333435058594)<br />选定历史版本Rc-1，记录其w为使Rc-1变得不合法的第一个位置，并设定mul的关系如下<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705685954093-21ea6f30-21c6-4991-b919-59e97689d2f5.png#averageHue=%23f7f6f4&clientId=u4b9ff6b1-0dc3-4&from=paste&height=49&id=u984f9bda&originHeight=61&originWidth=170&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=2866&status=done&style=none&taskId=u8041a37e-d2a8-47ef-8979-10719717f91&title=&width=137.92593383789062)<br />可构造序列如下，该序列包含i-w-1项0，可满足上述条件中对R'序列性质的要求<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705685585968-f54b73bf-c52e-4b48-8fbe-a4a14fdf8201.png#averageHue=%23f2f2f2&clientId=u4b9ff6b1-0dc3-4&from=paste&height=50&id=u9c5f3258&originHeight=81&originWidth=554&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=4665&status=done&style=none&taskId=u874ad2d4-ad24-4ca9-a88a-45b6af146dc&title=&width=340.35418701171875)<br />因此，我们找到了前i项序列{ai}的最短线性递推数列<br />遵循上述流程我们可以求得所给定序列的最短线性递推式，因此，可对每段子序列采用如上算法计算其最短线性递推式长度，并将其记为数列{Lm}

3. 计算理论完全随机序列的理论均值 µ与各项参数Ti，NIST标准所给定的公式如下：

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705686624985-adca4905-001d-4f70-9964-53771e792592.png#averageHue=%23faf8f6&clientId=u4b9ff6b1-0dc3-4&from=paste&height=88&id=u05ba6595&originHeight=102&originWidth=564&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17165&status=done&style=none&taskId=ue0c6f679-076c-4184-8aba-cf26e878ce9&title=&width=486.7778015136719)<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705686632671-9aa415a0-2e20-4749-9116-abe09e772a9d.png#averageHue=%23f9f6f3&clientId=u4b9ff6b1-0dc3-4&from=paste&height=35&id=udd6e6c35&originHeight=41&originWidth=591&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=10583&status=done&style=none&taskId=udf36d075-7816-49bc-aff6-4f79ba79087&title=&width=500.7778015136719)

4. 设置序列{v0...v6}，依据NIST标准，序列各项值定义如下

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705686462273-60f6972e-6701-4a83-ba25-374ef7455a7f.png#averageHue=%23fbf9f6&clientId=u4b9ff6b1-0dc3-4&from=paste&height=163&id=ufd51c5cd&originHeight=220&originWidth=497&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=41806&status=done&style=none&taskId=u9ada4bfd-571d-4a17-8457-efdba24605c&title=&width=368.148174155071)

6. 计算统计量X2(obs)，并求出其P值与显著性水平进行比较，NIST标准所提供的公式如下

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705686565253-f0b756f1-0f71-43a2-9054-18807fbee14f.png#averageHue=%23fcfaf9&clientId=u4b9ff6b1-0dc3-4&from=paste&height=147&id=ufdb79b75&originHeight=198&originWidth=769&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=39132&status=done&style=none&taskId=u04e91bf8-33dc-4eb3-ac7e-9c83c0546f8&title=&width=569.6296698697175)<br />通过统计学方法，上述检测方法能够可量化的评估生成序列相较于LFSR生成序列是否具备一定的复杂程度，从而能够较为有效地检验随机数生成器的安全性。
<a name="eJX2i"></a>
### 数列生成效率
数列生成效率主要通过时间复杂度分析与基准测试两类方法进行开展，报告尝试对此进行阐述
<a name="N9t0A"></a>
#### 时间复杂度分析
在密码学领域下的时间复杂度分析主要采用时间复杂度分析理论中的RAM模型进行分析，首先，时间复杂度分析将算法具体执行步骤抽象为理想模型下的计算机元指令操作并假定每个元指令的操作时间相等，随后通过数学分析使用渐进复杂度的表示形式表示算法运行时间与输入参数大小的增长关系，从而实现对算法时间消耗增长的数学描述，需要注意的是，在密码学领域下的输入参数大小往往以输入数值（组）的二进制形式长度进行计算。时间复杂度分析能够较好的反应算法耗时随输入增长的变化趋势，该趋势主要决定了算法的运行效率，因此该分析方法十分重要。但常见的时间复杂度分析往往忽略了低次项数与各项系数，因此可能难以对算法耗时做出精确的数学描述，在特定的条件下，该算法所忽略的这些系数可能会较为显著的影响算法的执行效率。
<a name="x7YTu"></a>
#### 基准测试
基准测试主要通过设立统一的算法测试平台对各算法效率进行测试，通过尽可能保证测试环境的与输入参数的一致性，基准测试能够较为公平有效地对各算法的实际运行耗时进行对比，从而对算法的生成效率进行评估。然而与此同时，基准测试要求对特定算法进行基于特定平台的代码实现，部署公平有效地测试环境往往较为复杂。同时，基准测试的算法运行耗时往往存在一定误差，需要进行多次测试以降低误差的干扰。对于耗时较短的算法，由于其生成耗时结果受到误差影响可能较为严重，因此可能无法测得具有参考价值的运行耗时结果，需要扩增输入大小以提高耗时测测量精度。
<a name="aOVNx"></a>
## 常见的伪随机数算法评估
由前文分析可知，伪随机数生成器可依据其安全性划分为普通PRNG与CSPRNG两类生成器。随着密码学与数学理论的发展，现如今学界已提出数百种随机数生成算法，其中许多已被广泛应用。现有的数百种随机数算法中，很大一部分算法是基于一些较早的，较为基础性的生成算法进一步改进而得到的。本报告尝试分析普通随机数生成器中四种经典的伪随机数生成算法及其衍生改进算法，以及三种经典的密码学安全的随机数生成器。同时，本报告将提供部分随机数生成器算法的java代码实现，并尝试使用NIST所提供的随机数生成器测试套件[13]对所实现的随机数生成器进行测试。
<a name="evFga"></a>
### 普通随机数生成器算法
<a name="FI4Um"></a>
#### 平方取中法
<a name="aN0t9"></a>
##### 原始平方取中算法
平方取中法是由冯·诺依曼于1949年所提出的一种用于生成为随机数序列的生成算法[14]。做为最早一批所提出的伪随机数算法，平方取中法较为简单，能够有效生成看似随机的伪随机数序列，但后续的研究表明其该算法的生成序列统计学随机性较差。平方取中法的算法过程如下：

1. 选取一个m位数x作为种子
2. 计算x2，并在结果前补0使其成为一个2m位的数字
3. 选取中间的m位数作为新的种子，重复上述迭代过程

该算法主体的Java代码实现如下
```java
    @Override
    public long nextLong() {
        long next = seed * seed / TAIL;
        long res = 0;
        long term = 1;
        for (int i = 0; i < LENGTH; i++) {
            int v = (int) (next % 10);
            res += term * v;
            term *= 10;
            next /= 10;
        }
        seed = res;
        return res;
    }
```
选取种子x=1234，m=4，经测试可以发现，该算法能够生成随机序列，效果如下<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705739631770-98acd89a-853b-4f59-8cbb-30402f237031.png#averageHue=%23f8f6f4&clientId=u39bb18a8-e373-4&from=paste&height=558&id=ue29260fb&originHeight=821&originWidth=371&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=83603&status=done&style=none&taskId=ufe72bb18-3fb9-4d04-9c5d-5e38baf4826&title=&width=252)<br />同时测试观察到，自第56次生成随机数后，该算法陷入恒0循环，这提示该算法所生成的有效伪随机序列长度可能与初始种子长度有关，同时提示该算法可能在特定种子下陷入循环中，无法生成有效的伪随机序列。由于当前伪随机数较小时，平方取中法很可能取得全0序列从而陷入恒0循环中，这提示该算法所生成的伪随机数序列的随机数分布可能并不均匀。<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705739766860-07528959-ba1e-493b-b68b-f7fe40bcbb9d.png#averageHue=%23f8f6f4&clientId=u39bb18a8-e373-4&from=paste&height=246&id=u13e164b0&originHeight=332&originWidth=277&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=25632&status=done&style=none&taskId=u02e1bc2d-6055-4313-b860-260c2cbc054&title=&width=205.18519967998927)<br />以种子x=24，m=2为例，该算法所生成种子陷入了24-57循环，提示该伪随机数算法生成效果与初始种子具有较强的关系，同时提示该伪随机数算法周期可能较短。<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705739989746-d191be3b-c547-41d4-865f-cd8e3dd6643a.png#averageHue=%23f7f5f3&clientId=u39bb18a8-e373-4&from=paste&height=323&id=u41ced367&originHeight=436&originWidth=286&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=37964&status=done&style=none&taskId=ue9c13082-eac1-4ac6-866d-10054a905cf&title=&width=211.85186681760624)<br />使用NIST测试工具对该伪随机数算法所生产序列进行测试，选取初始种子位64位比特长度数字，测试序列长度为1000,000*10个比特位（后续实验采用相同的生成序列长度），测试结果如下

| 序号 | 测试项目 | 通过测试数/总测试数 | 平均P值 |
| --- | --- | --- | --- |
| 1 | Frequency | 0/10 | 0 |
| 2 | BlockFrequency | 0/10 | 0 |
| 3 | CumulativeSums | 0/20 | 0 |
| 4 | Runs | 0/10 | 0 |
| 5 | LongestRun | 0/10 | 0 |
| 6 | Rank | 9/10 | 0.122325 |
| 7 | FFT | 0/10 | 0 |
| 8 | NonOverlappingTemplate | 0/1480 | 0 |
| 9 | OverlappingTemplate | 0/10 | 0 |
| 10 | Universal | 0/10 | 0 |
| 11 | ApproximateEntropy | 0/10 | 0 |
| 12 | RandomExcursions | ERR | / |
| 13 | RandomExcursionsVariant | ERR | / |
| 14 | Serial | 0/20 | 0 |
| 15 | LinearComplexity | 9/10 | 0.739918 |

可以看到，即便是待测序列中并不存在全0循环，平方取中法所NIST检测后的数据结果仍仅通过了2项测试，这反应出该算法的随机性可能较差，该结论也同样被先前研究所证实。
<a name="sBaUg"></a>
##### Weyl序列平方取中算法
Weyl序列平方取中算法是由Bernard Widynski所提出的改进型平方取中算法[15]。该算法借助Weyl序列改进了原始平方取中算法，显著延长了其生成的随机序列周期性与生成分布均匀性，同时避免了算法最终陷入全0循环。该算法的具体过程如下：

1. 初始化64位种子x，Weyl序列w与序列常数s，其中s为Weyl序列中一个二进制形式下0与1数量大致相等的奇数常数，而Weyl序列w被定义为一个周期为264的循环序列，其表达式如下

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705762467065-5a14e9bb-509e-46e3-a224-2964ad3b7ad3.png#averageHue=%23f1f1f1&clientId=u39bb18a8-e373-4&from=paste&height=41&id=uc7dc33ed&originHeight=68&originWidth=412&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=3776&status=done&style=none&taskId=u11a6e85f-d513-4000-93b6-b4e6d8ce3d6&title=&width=249.18521118164062)

2. 计算当前项随机数xi+1的值，算法如下

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705762544697-0a1bcc03-23cd-48eb-9eda-2ae923e0af63.png#averageHue=%23f3f3f3&clientId=u39bb18a8-e373-4&from=paste&height=52&id=u33c274dd&originHeight=81&originWidth=466&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=4458&status=done&style=none&taskId=u6a36303e-6b46-4e8f-97ec-76ad3b0622f&title=&width=298.1852111816406)<br />其中，middle为平方取中法算法中进行补零并截取中间项的操作函数，重复该即可生成所需的随机序列。<br />上述过程主要部分的Java代码实现如下
```java
UnsignedLong seed,w,weylConst;//using Guava UnsignedLong.
//initialization
///...
@Override
    public long nextLong() {
        seed = seed.times(seed);
        w = w.plus(weylConst);
        seed = seed.plus(w);
        long xBits = seed.longValue();
        long high = (xBits >>> 32);
        long low = (xBits << 32);
        seed=UnsignedLong.fromLongBits(high | low);
        return high;
    }
```
选取种子x=0,设置Weyl序列w=0，weylConst=0xb5ad4eceda1ce2a9L，所生成的随机序列效果如下，可以看到算法正确地生成了随机序列<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705763414377-81dfdb14-d38a-4101-abf5-f5e4dfe9dea9.png#averageHue=%23f6f3f1&clientId=u39bb18a8-e373-4&from=paste&height=442&id=u427be777&originHeight=597&originWidth=401&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=74056&status=done&style=none&taskId=udacd62b6-4e0a-4bae-8191-9fb2bb5ee71&title=&width=297)<br />在论文中，Widynski详细证明了通过引入Weyl序列显著延长了生成序列的周期长度，同时避免生成序列陷入恒0循环。同时，Windynski证明了生成序列的分布均匀性，同时BigCrush工具的检测结果表明该算法通过了随机性检验。本报告尝试使用NIST伪随机数生成器测试工具对该算法生成序列随机性进行检验，测试结果如下

| 序号 | 测试项目 | 通过测试数\\总测试数 | 平均P值 |
| --- | --- | --- | --- |
| 1 | Frequency | 10\\10 | 0.534146 |
| 2 | BlockFrequency | 10\\10 | 0.739918 |
| 3 | CumulativeSums | 20\\20 | 0.72278 |
| 4 | Runs | 10\\10 | 0.350485 |
| 5 | LongestRun | 10\\10 | 0.066882 |
| 6 | Rank | 10\\10 | 0.534146 |
| 7 | FFT | 10\\10 | 0.739918 |
| 8 | NonOverlappingTemplate | 1467\\1480 | 0.484722 |
| 9 | OverlappingTemplate | 10\\10 | 0.350485 |
| 10 | Universal | 10\\10 | 0.534146 |
| 11 | ApproximateEntropy | 9\\10 | 0.350485 |
| 12 | RandomExcursions | 56\\56 | / |
| 13 | RandomExcursionsVariant | 126\\126 | / |
| 14 | Serial | 18\\20 | 0.442316 |
| 15 | LinearComplexity | 10\\10 | 0.911413 |

可以看到，生成序列通过了绝大多数的统计学随机性测试，表明该生成序列具备较好的统计学随机性，提示该生成器的生成质量较高，同时分析其算法过程可以发现，该算法相较于原始平方取中法仅增加了较为简单的Weyl序列计算加和过程，该算法的时间复杂度与原始算法相当，具备较高的生成效率。
<a name="if4dU"></a>
#### 线性同余法
线性同余法是由W. E. Thomson于1958年所提出的伪随机数生成算法，该算法历史悠久，算法过程简单，相较于平方取中法可以生成质量更高的随机数生成序列，因此得以被广泛应用于各种普通伪随机数需求场景中。同时由于该算法的经典性，许多伪随机数生成算法往往基于该算法原始形式进行改进与扩展，如Park-Miller generator，Permuted Congruential Generator等算法，本报告尝试对该算法原始形式及其改进形式进行阐述与测试
<a name="mNEE0"></a>
##### 原始线性同余算法
原始线性同余法的算法过程大致如下：

1. 初始化伪随机数生成器种子X0，生成器系数有：模数m，乘数a与增量c，其中若c为0，则该算法为Lehmer RNG算法。该LCG算法生成序列的最大周期为m，且多数时候无法达到m。为尽可能增大生成序列的周期长度，提高生成序列的随机性，通常采取如下的系数选择方法[17][18]：
   1. 选取m为尽可能大的数，往往选取素数或2的幂
   2. 若c不等于0，则在满足一定性质的条件下，该生成器输入任意种子均可以生成周期长度等于m的随机数序列，其性质如下
      1. m与c需互质
      2. a-1可被m的任意质因子整除
      3. 若m可被4整除，则a-1可被4整除
2. 定义生成序列{Xn}，，其生成序列的递归公式如下

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705765640932-dc9b0635-44f9-4186-bc70-c41b25f16cc4.png#averageHue=%23f3f3f3&clientId=u39bb18a8-e373-4&from=paste&height=49&id=wFU90&originHeight=81&originWidth=436&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=4021&status=done&style=none&taskId=udc01b1c8-1a2a-4da8-acb3-ba7da72a2fd&title=&width=263.9583435058594)<br />上述算法主体部分的Java代码实现如下
```java
    @Override
    public long nextLong() {
        seed = (seed * a + c) & (mod - 1);
        return (int)seed >>> (48 - 32);
    }
```
使用NIST伪随机数生成器测试工具对该算法生成序列随机性进行检验，测试结果如下

| 序号 | 测试项目 | 通过测试数\\总测试数 | 平均P值 |
| --- | --- | --- | --- |
| 1 | Frequency | 10\\10 | 0.017912 |
| 2 | BlockFrequency | 10\\10 | 0.911413 |
| 3 | CumulativeSums | 20\\20 | 0.431122 |
| 4 | Runs | 10\\10 | 0.739918 |
| 5 | LongestRun | 10\\10 | 0.739918 |
| 6 | Rank | 10\\10 | 0.911413 |
| 7 | FFT | 10\\10 | 0.534146 |
| 8 | NonOverlappingTemplate | 1461\\1480 | 0.508226 |
| 9 | OverlappingTemplate | 10\\10 | 0.350485 |
| 10 | Universal | 10\\10 | 0.213309 |
| 11 | ApproximateEntropy | 10\\10 | 0.534146 |
| 12 | RandomExcursions | 48\\48 | / |
| 13 | RandomExcursionsVariant | 108\\108 | / |
| 14 | Serial | 20\\20 | 0.373728 |
| 15 | LinearComplexity | 10\\10 | 0.739918 |

出乎意料的是，原始线性同余法算法虽然较为简单，但仍基本通过了全部的统计学随机性测试，表明该算法具备较好的统计学随机性。
<a name="v9JX1"></a>
##### Park-Miller算法
Park-Miller算法即为Lehmer RNG的特殊实现，1988年Park and Miller的论文[19]建议将生成器参数设置为m = 231 − 1，a=75，从而提供一个较好的生成序列。<br />依此调节LCG算法的参数，并使用NIST伪随机数生成器对该算法生成序列随机性进行检验，测试结果如下

| 序号 | 测试项目 | 通过测试数\\总测试数 | 平均P值 |
| --- | --- | --- | --- |
| 1 | Frequency | 10\\10 | 0.911413 |
| 2 | BlockFrequency | 10\\10 | 0.534146 |
| 3 | CumulativeSums | 20\\20 | 0.442316 |
| 4 | Runs | 10\\10 | 0.350485 |
| 5 | LongestRun | 10\\10 | 0.350485 |
| 6 | Rank | 10\\10 | 0.534146 |
| 7 | FFT | 10\\10 | 0.534146 |
| 8 | NonOverlappingTemplate | 1458\\1480 | 0.507882 |
| 9 | OverlappingTemplate | 10\\10 | 0.350485 |
| 10 | Universal | 10\\10 | 0.122325 |
| 11 | ApproximateEntropy | 10\\10 | 0.122325 |
| 12 | RandomExcursions | 48\\48 | / |
| 13 | RandomExcursionsVariant | 108\\108 | / |
| 14 | Serial | 20\\20 | 0.739918 |
| 15 | LinearComplexity | 10\\10 | 0.739918 |

可以看到，在正确地设置LCG参数的条件下，LCG类算法均具备较好的统计学随机性。
<a name="TUF9L"></a>
##### PCG算法
PCG算法是一种基于LCG算法的改进算法，由Dr. M.E. O'Neill于2014年提出[20]。该算法通过添加一个输出置换函数对输出结果的个各比特位进行打乱混合，从而避免了LCG算法低位周期较短的问题，其中一种输出转置算法下的Java代码实现如下
```java
    private int rotate(int x, int r) {
        return x >>> r | x << (-r & 31);
    }
    @Override
    public long nextLong() {
        UnsignedLong x = state;
        int count = (int) (x.longValue() >>> 59);
        state = x.times(multiplier).plus(increment);
        long x2 = x.longValue();
        x2 ^= x2 >>> 18;
        x = UnsignedLong.fromLongBits(x2);
        int res = rotate((int) (x.longValue() >>> 27), count);
        return Integer.toUnsignedLong(res);
    }
```
使用NIST随机数生成器检测工具对该算法生成序列随机性进行检验，测试结果如下

| 序号 | 测试项目 | 通过测试数\\总测试数 | 平均P值 |
| --- | --- | --- | --- |
| 1 | Frequency | 10\\10 | 0.739918 |
| 2 | BlockFrequency | 10\\10 | 0.911413 |
| 3 | CumulativeSums | 20\\20 | 0.167817 |
| 4 | Runs | 10\\10 | 0.122325 |
| 5 | LongestRun | 10\\10 | 0.350485 |
| 6 | Rank | 10\\10 | 0.534146 |
| 7 | FFT | 10\\10 | 0.739918 |
| 8 | NonOverlappingTemplate | 1468\\1480 | 0.540027 |
| 9 | OverlappingTemplate | 10\\10 | 0.911413 |
| 10 | Universal | 10\\10 | 0.739918 |
| 11 | ApproximateEntropy | 10\\10 | 0.534146 |
| 12 | RandomExcursions | 48\\48 | / |
| 13 | RandomExcursionsVariant | 108\\108 | / |
| 14 | Serial | 20\\20 | 0.534146 |
| 15 | LinearComplexity | 10\\10 | 0.911413 |

可以看到，该算法基本通过了统计学随机性检验，具备较好的生成随机性。
<a name="roc7J"></a>
#### 延迟斐波那契法
延迟斐波那契算法（LFG）是一类基于斐波那契序列扩展形式的生成算法，其最早形式由G. J. Mitchell与D. P. Moore于1958年提出[17]。该类算法的通用递归表达式可表示如下<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705807786480-4aa9c81d-a53e-49b6-980f-44f299f7a520.png#averageHue=%23f1f1f1&clientId=u70b42ad5-e1f1-4&from=paste&height=54&id=u28d1b729&originHeight=73&originWidth=574&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=5622&status=done&style=none&taskId=u8a21ffd3-a67a-4a57-97d3-9fa07980c95&title=&width=425.1852152213496)<br />其中，星号表示某种二元关系运算符，如加和运算，乘积运算等。本报告尝试对原始的延迟斐波那契算法进行阐述
<a name="OBC5U"></a>
##### 原始延迟斐波那契算法
G. J. Mitchell与D. P. Moore提出的原始算法的递归序列定义如下<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705808227712-da67aba2-a5c7-46b0-b791-be3497a46931.png#averageHue=%23eeeeee&clientId=u70b42ad5-e1f1-4&from=paste&height=47&id=u51e2b104&originHeight=63&originWidth=743&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=6271&status=done&style=none&taskId=u150ad0db-5d6d-4ab7-897c-607112799af&title=&width=550.370409249935)<br />原始算法的生成种子为序列{X0...X54}，m为一个充分大的偶数模数，通常选取m值为2的幂次方<br />通用LFG算法的Java实现如下，其中，LEN为生成序列数组长度，使用l，r表示当前生成项所依赖的前项
```java
//...initalize...
//        LEN = k;
//        LAG_1 = LEN - j;
//        LAG_2 = 0;
//        pointer = LEN - 1;
//...
@Override
    public long nextLong() {
        pointer = (pointer + 1) % LEN;
        int l = (LAG_1 + pointer) % LEN;
        int r = (LAG_2 + pointer) % LEN;
        return seeds[pointer] =
                operator.operate(seeds[l], seeds[r]) % mod;
    }
```
由于现有的LFG应用常借助LCG生成初始种子序列，本报告对此进行了实现，选取seed=10, m=232，生成结果如下，可以看到生成器正确生成了伪随机序列<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705812017980-93fd7ac4-39e3-47f9-80f6-eac333eafd28.png#averageHue=%23f6f3f1&clientId=u70b42ad5-e1f1-4&from=paste&height=276&id=ub90b27e5&originHeight=372&originWidth=384&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=44233&status=done&style=none&taskId=u0952ea91-58b5-46c2-a927-29fe94a66b0&title=&width=284.44446453832444)<br />使用NIST随机性检测工具对所生成序列进行检验，测试结果如下

| 序号 | 测试项目 | 通过测试数\\总测试数 | 平均P值 |
| --- | --- | --- | --- |
| 1 | Frequency | 0\\10 | 0 |
| 2 | BlockFrequency | 0\\10 | 0 |
| 3 | CumulativeSums | 0\\20 | 0 |
| 4 | Runs | 0\\10 | 0 |
| 5 | LongestRun | 10\\10 | 0.534146 |
| 6 | Rank | 10\\10 | 0.122325 |
| 7 | FFT | 10\\10 | 0.350485 |
| 8 | NonOverlappingTemplate | 783\\1480 | 0.143858 |
| 9 | OverlappingTemplate | 0\\10 | 0 |
| 10 | Universal | 10\\10 | 0.534146 |
| 11 | ApproximateEntropy | 0\\10 | 0 |
| 12 | RandomExcursions | / | / |
| 13 | RandomExcursionsVariant | / | / |
| 14 | Serial | 10\\20 | 0.0000995 |
| 15 | LinearComplexity | 10\\10 | 0.534146 |

可以看到，该伪随机数生成器仅通过了部分随机性检验测试，提示该伪随机数生成器可能质量不佳。<br />通过将每次生成数字奇偶性转化成图像的黑/白像素，我们可以生成随机序列的奇偶性分布图，下图的LFG奇偶性分布图直观的展示了LFG生成序列内部具备较强的奇偶性关系，这提示该生成器的生成序列可能具备较强的内部规律，验证了统计学测试的结果。<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705812749140-1b684a2e-88ef-4c76-b241-fb3826d4e915.png#averageHue=%236d6d6d&clientId=u70b42ad5-e1f1-4&from=paste&height=392&id=u07a3da8f&originHeight=662&originWidth=789&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=87324&status=done&style=none&taskId=u9ba9cc49-965a-4b38-b462-9dc769ce664&title=&width=467.4444580078125)
<a name="EIpuh"></a>
##### 改进型斐波那契法
基础的对原有LFG算法进行改进的操作往往围绕其通用递归式进行改进，如选用乘法，异或作为二元关系运算符，以Marsaglia所提出的改进算法为例，该算法使用乘法运算符进行迭代运算，其表达式如下[21]<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705815157099-899f0c31-a7c1-4b59-b245-06e0832d3595.png#averageHue=%23eeeeee&clientId=u70b42ad5-e1f1-4&from=paste&height=42&id=uc71aa8fd&originHeight=63&originWidth=802&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=6795&status=done&style=none&taskId=u6db88288-52a9-418f-b049-c37d8ef4fef&title=&width=532.0740966796875)<br />其中，模数m为4的倍数，而种子序列{X0...X54}为奇数，且不全于模4下同余1。依此调节LFG算法的参数，并使用NIST伪随机数生成器对该算法生成序列随机性进行检验，测试结果如下：

| 序号 | 测试项目 | 通过测试数\\总测试数 | 平均P值 |
| --- | --- | --- | --- |
| 1 | Frequency | 10\\10 | 0.122325 |
| 2 | BlockFrequency | 0\\10 | 0 |
| 3 | CumulativeSums | 20\\20 | 0.373728 |
| 4 | Runs | 10\\10 | 0.350485 |
| 5 | LongestRun | 0\\10 | 0 |
| 6 | Rank | 2\\10 | 0 |
| 7 | FFT | 0\\10 | 0 |
| 8 | NonOverlappingTemplate | 0\\1480 | 0 |
| 9 | OverlappingTemplate | 0\\10 | 0 |
| 10 | Universal | 0\\10 | 0 |
| 11 | ApproximateEntropy | 0\\10 | 0 |
| 12 | RandomExcursions | 3\\12 | / |
| 13 | RandomExcursionsVariant | 72\\72 | / |
| 14 | Serial | 0\\20 | 0 |
| 15 | LinearComplexity | 10\\10 | 0.534146 |

相较于原始算法，改进型算法相较于原始算法通过了不同的测试，在频率测试中表现较好，但同时存在一些未能通过的统计学测试，提示该算法可能不能很好的生成质量较高的伪随机序列。
<a name="Vv0Zw"></a>
#### 线性反馈位移寄存器算法
线性反馈位移寄存器算法（LFSR）是一种基于移位寄存器与线性反馈函数的伪随机数生成算法，其主要创始人为Golomb, Solomon W. [22]，由于其生成序列较线性同余法具有更高的抗预测性，因而该算法及其改进形式受到了广泛应用。其改进与衍生形式包括了如Mersenne Twister算法等。本报告尝试对该算法原始形式及其衍生算法进行阐述与测试。
<a name="ZTak7"></a>
##### 原始线性反馈位移寄存器算法
原始线性反馈寄存器的通用表达形式如下<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705819622556-539cdb2f-ed46-40e2-9b3c-d1fd59bdfdba.png#averageHue=%23f2f2f2&clientId=u5882a38d-f907-4&from=paste&height=50&id=u3f45b923&originHeight=67&originWidth=499&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=3763&status=done&style=none&taskId=uac01026f-56f4-4a15-b1b4-d8c59ee61e4&title=&width=369.62965574120807)<br />其中，F为线性多元函数，其通用表达式为<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705819705197-1fde7175-7f61-4cd0-a354-bce33c96cc1e.png#averageHue=%23f6f6f6&clientId=u5882a38d-f907-4&from=paste&height=102&id=u9cf99a6c&originHeight=155&originWidth=326&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=4177&status=done&style=none&taskId=u4c1cc9c9-ab34-4075-bcc1-65469808cc7&title=&width=214.4814910888672)<br />本报告尝试基于此实现32位的线性反馈位移寄存器算法，选取线性反馈项为[32,22,2,1,0]，选取项系数为1，其代码实现如下。
```java
    @Override
    public long nextLong() {
        long bit = ((seed >>> 0) ^ (seed >>> 1) ^ (seed >>> 2) ^ (seed >>> 22) ^ (seed >>> 32)) & 1L;
        seed = (seed >>> 1) | (bit << 31);
        return seed;
    }
```
选取seed=10, 生成结果如下，可以看到生成器正确生成了伪随机数序列<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705820600022-696564ac-34bc-494b-99c4-cde7c2391000.png#averageHue=%23f5f2f0&clientId=u5882a38d-f907-4&from=paste&height=534&id=u1d9a2973&originHeight=722&originWidth=377&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=90519&status=done&style=none&taskId=u1e892d51-bcd0-47f3-8902-d700d426ae6&title=&width=279)<br />使用NIST随机性检测工具对所生成序列进行检验，测试结果如下

| 序号 | 测试项目 | 通过测试数\\总测试数 | 平均P值 |
| --- | --- | --- | --- |
| 1 | Frequency | 10\\10 | 0.911413 |
| 2 | BlockFrequency | 10\\10 | 0.350485 |
| 3 | CumulativeSums | 20\\20 | 0.72278 |
| 4 | Runs | 10\\10 | 0.911413 |
| 5 | LongestRun | 10\\10 | 0.350485 |
| 6 | Rank | 0\\10 | 0 |
| 7 | FFT | 10\\10 | 0.350485 |
| 8 | NonOverlappingTemplate | 1462\\1480 | 0.523586 |
| 9 | OverlappingTemplate | 10\\10 | 0.213309 |
| 10 | Universal | 10\\10 | 0.739918 |
| 11 | ApproximateEntropy | 9\\10 | 0.739918 |
| 12 | RandomExcursions | 48\\48 | / |
| 13 | RandomExcursionsVariant | 108\\108 | / |
| 14 | Serial | 20\\20 | 0.630949 |
| 15 | LinearComplexity | 0\\10 | 0 |

可以看到，线性反馈位移寄存器算法生成了较好的随机数序列，通过了绝大多数的统计学测试，但未通过Rank测试于LinearComplexity测试。<br />Rank测试即为矩阵秩测试，该测试主要用于测试随机数序列内部的线性相关性，而LinearComplexity即为线性复杂度测试，该测试反映了各子序列的LFSR长度。由于该算法所使用的线性反馈寄存器位数较短，该算法并未通过上述两项测试，契合了前文中对该类测试的理论分析，表明线性反馈寄存器可能无法生成充分复杂的随机数算法，其序列内部具备一定的相关性。
<a name="Uuueu"></a>
##### Mersenne Twister算法
Mersenne Twister算法是由 Makoto Matsumoto与Takuji Nishimura所开发的算法[23]，该算法基于矩阵线性递归实现，可以生成相当长的序列生成周期（如MT19937算法的生成序列周期为219937-1），具备较强的随机质量，其算法大致过程如下：

1. 接收初始种子X0，随后通过递推式求出梅森旋转链作为初始参数，其递推公式如下，其中f与w为设定系数

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705822490701-75c6347b-3cc6-4b0b-81a4-ee8d799675ae.png#averageHue=%23f4f4f4&clientId=u5882a38d-f907-4&from=paste&height=54&id=uc7982827&originHeight=96&originWidth=624&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=6725&status=done&style=none&taskId=u3b47c280-dbce-4efc-94da-1a3f2ecf49b&title=&width=348.2037048339844)

2. 遍历旋转链，对该旋转链执行梅森旋转算法，该算法的递推公式如下，其中u与l为设定系数，A为旋转矩阵

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705822676152-50de9001-b151-4741-ab68-a4a1b8d6a995.png#averageHue=%23f4f4f4&clientId=u5882a38d-f907-4&from=paste&height=58&id=uccf73abb&originHeight=99&originWidth=552&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=6337&status=done&style=none&taskId=u6cad96ac-7268-4150-9723-6964588e260&title=&width=321.8819580078125)

3. 对梅森旋转算法结果进行处理，求解得生成的随机数项，该过程的公式如下

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705822777909-97b98f78-e497-45d8-9b65-143d47f7ebdd.png#averageHue=%23ededed&clientId=u5882a38d-f907-4&from=paste&height=124&id=ubdbef730&originHeight=103&originWidth=213&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=9103&status=done&style=none&taskId=ube268d6c-27c7-4bd2-8ce2-dfbf077afaa&title=&width=255.77316284179688)<br />本项目尝试使用java代码对该算法进行实现，其代码主体部分如下
```java
    private void initialize(){
        for (int i = 1; i < N; i++) {
            mt[i] = (F * (mt[i - 1] ^ (mt[i - 1] >> 30)) + i) & D;
        }
    }
    private void twist() {
        for (int i = 0; i < N; i++) {
            long x = (mt[i] & MASK_UPPER) + (mt[(i + 1) % N] & MASK_LOWER);
            long xA = (x >> 1) & D;
            if ((x & 1) != 0) {
                xA ^= A;
            }
            mt[i] = mt[(i + M) % N] ^ xA;
        }
        index = 0;
    }
    @Override
    public long nextLong() {
        if (index >= N) {
            twist();
        }
        long y = mt[index];
        y ^= (y >> U);
        y ^= (y << S) & B;
        y ^= (y << T) & C;
        y ^= (y >> L);
        index++;
        return y & D;
    }
```
使用NIST随机性检测工具对所生成序列进行检验，测试结果如下

| 序号 | 测试项目 | 通过测试数\\总测试数 | 平均P值 |
| --- | --- | --- | --- |
| 1 | Frequency | 10\\10 | 0.066882 |
| 2 | BlockFrequency | 10\\10 | 0.350485 |
| 3 | CumulativeSums | 20\\20 | 0.739918 |
| 4 | Runs | 10\\10 | 0.739918 |
| 5 | LongestRun | 10\\10 | 0.739918 |
| 6 | Rank | 10\\10 | 0.534146 |
| 7 | FFT | 10\\10 | 0.213309 |
| 8 | NonOverlappingTemplate | 1463\\1480 | 0.469501 |
| 9 | OverlappingTemplate | 10\\10 | 0.350485 |
| 10 | Universal | 10\\10 | 0.213309 |
| 11 | ApproximateEntropy | 10\\10 | 0.911413 |
| 12 | RandomExcursions | 40\\40 | / |
| 13 | RandomExcursionsVariant | 88\\90 | / |
| 14 | Serial | 20\\20 | 0.19283 |
| 15 | LinearComplexity | 10\\10 | 0.350485 |

可以看到，MT算法所生成的随机数序列基本通过了统计学检验，有效改善了LFSR算法生成序列复杂度欠佳的问题，其生成序列具备较高的随机性质量。
<a name="lXnUH"></a>
### 密码学安全的随机数生成器算法
由前文分析可知，密码学安全的随机数生成器算法往往基于密码学理论所设计并证明，主要可分为基于密码学原语所设计的伪随机数生成器，基于数学难题所涉及的伪随机数生成器两类。同时，在实际应用中，如操作系统等平台往往借助外界物理设备参数的引入以实现近似于真随机数的随机数生成算法。本报告尝试分析两种CSPRNG算法，并使用NIST所提供的随机数生成器测试套件对所实现的随机数生成器进行测试。
<a name="k6eau"></a>
#### Blum Blum Shub算法
Blum Blum Shub算法是 Lenore Blum, Manuel Blum与Michael Shub于1986年所提出的算法，该算法基于大因数分解这一数学难题所设计，在现有理论与技术下具备较高的密码学安全水平[24]，算法的大致过程如下：

1. 选取两个大素数p与q为种子，计算n=p*q 素数p与q应满足如下性质

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705857884685-a4eb8fa4-eba5-4ee7-8f5a-76d5602a2cd1.png#averageHue=%23ebebeb&clientId=u816e7609-1df0-4&from=paste&height=41&id=u1ed4f7d5&originHeight=56&originWidth=307&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=2878&status=done&style=none&taskId=u3f3de03a-758d-42fd-a627-5c5d0e0c592&title=&width=227.40742347204585)

2. 接收随机数种子x0，使用下列公式进行随机数生成迭代，初始种子必须满足与n互质，且大于1

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705858124840-3117c8c2-26e0-4d73-856b-a449621763d2.png#averageHue=%23f1f1f1&clientId=u816e7609-1df0-4&from=paste&height=47&id=ud7b08fcf&originHeight=64&originWidth=282&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=2336&status=done&style=none&taskId=uc1c2ec7a-8db5-4050-8fe9-1e30d60713b&title=&width=208.88890364533202)

3. 选取每项随机数的最低有效位，该最低有效位序列构成了生成器的生成序列

该算法主体部分的java代码实现如下，其中，大素数的选取使用了Java所提供的Miller-Rabin素性测试方法
```java
//BigInteger p,q,n,seed...
	public BBS() {
        super(-1);//unused
        p = bigPrime();
        q = bigPrime();
        n = p.multiply(q);
        seed = bigPrime();
    }
    public BigInteger bigPrime() {
        Random rnd = new Random();
        BigInteger res;
        do {
            res = BigInteger.probablePrime(bitLength, rnd);
        } while (res.mod(FOUR).equals(THREE) && res.isProbablePrime(certainty));
        return res;
    }

    @Override
    public boolean nextBit() {
        seed = seed.pow(2).mod(n);
        return seed.testBit(0);
    }
```
使用NIST随机性检测工具对所生成序列进行检验，测试结果如下

| 序号 | 测试项目 | 通过测试数\\总测试数 | 平均P值 |
| --- | --- | --- | --- |
| 1 | Frequency | 9\\10 | 0.350485 |
| 2 | BlockFrequency | 10\\10 | 0.534146 |
| 3 | CumulativeSums | 19\\20 | 0.516869 |
| 4 | Runs | 9\\10 | 0.534146 |
| 5 | LongestRun | 10\\10 | 0.739918 |
| 6 | Rank | 10\\10 | 0.122325 |
| 7 | FFT | 9\\10 | 0.534146 |
| 8 | NonOverlappingTemplate | 1471\\1480 | 0.501895 |
| 9 | OverlappingTemplate | 10\\10 | 0.739918 |
| 10 | Universal | 10\\10 | 0.213309 |
| 11 | ApproximateEntropy | 8\\10 | 0.534146 |
| 12 | RandomExcursions | 64\\64 | / |
| 13 | RandomExcursionsVariant | 144\\144 | / |
| 14 | Serial | 20\\20 | 0.825665 |
| 15 | LinearComplexity | 10\\10 | 0.739918 |

可以看到，BBS算法所生成的随机数序列基本通过了统计学检验，其生成序列具备较高的统计学随机性。
<a name="JkwfQ"></a>
#### Windows密码学安全伪随机数生成器
Windoews内部的RtlGenRandom函数提供了基于外部物理熵源的CSPRNG，依据所发布的算法摘要[25]，该算法采用SHA-1作为G函数，同时使用当前系统内部的变化参数作为熵源，如当前进程ID，高精度计数器，用户环境参数等，从而提高了其对抗攻击能力。查阅Java官方文档可知[26]，Java官方文档所提供的SecureRandom类在Windows操作系统环境下将使用RtlGenRandom函数生成随机序列，本报告基于此在windows环境下使用Java SecureRandom生成随机序列，从而实现对Windows所提供的随机变量生成器的测试，检测结果如下：

| 序号 | 测试项目 | 通过测试数\\总测试数 | 平均P值 |
| --- | --- | --- | --- |
| 1 | Frequency | 10\\10 | 0.213309 |
| 2 | BlockFrequency | 10\\10 | 0.911413 |
| 3 | CumulativeSums | 20\\20 | 0.562361 |
| 4 | Runs | 9\\10 | 0.739918 |
| 5 | LongestRun | 10\\10 | 0.534146 |
| 6 | Rank | 10\\10 | 0.534146 |
| 7 | FFT | 10\\10 | 0.911413 |
| 8 | NonOverlappingTemplate | 1467\\1480 | 0.544747 |
| 9 | OverlappingTemplate | 10\\10 | 0.534146 |
| 10 | Universal | 10\\10 | 0.739918 |
| 11 | ApproximateEntropy | 10\\10 | 0.122325 |
| 12 | RandomExcursions | 55\\56 | / |
| 13 | RandomExcursionsVariant | 126\\126 | / |
| 14 | Serial | 20\\20 | 0.637032 |
| 15 | LinearComplexity | 10\\10 | 0.534146 |

可以看到，Windows伪随机数发生器所创建的生成序列基本通过了统计学测试，具备较高的统计学随机性。
<a name="KrirH"></a>
### 总结
通过对经典的伪随机数生成器算法进行实验与测试可以发现，不同的PRNG生成算法所生成的随机序列具备较为明显的统计学差异，对于经典的生成算法，仅有LCG算法所生成的随机序列完整地通过了统计学测试，具备较好的统计学随机性，而原始LFSR算法除在线性复杂度上效果欠佳外，同样通过了大多数的统计学测试。对于原始平方取中法与LFG算法，由于其未能通过多数的统计学测试，提示该算法的生成质量可能较差。同时，对于由此类经典算法所衍生出的如MT算法、PCG算法、Weyl算法均完整地通过了统计学测试，同时对原有算法做出了进一步的改进，其生成器的质量较高。对于密码学安全级别的随机数生成器，所测试的BBS算法与WindowsCSPRNG接口均通过了随机性测试，算法同时具备较高的随机性与对抗攻击性。<br />综合上述实验结果，本报告尝试对PRNG算法的表现进行汇总评价，结果如下

| PRNG算法 | 随机性检验结果 | 生成序列效率 | 密码学安全 | 算法实现难度 |
| --- | --- | --- | --- | --- |
| 原始平方取中法 | 未通过 | 快 | 否 | 较低 |
| Weyl序列平方取中法算法 | 通过 | 快 | 否 | 较低 |
| 原始线性同余算法 | 通过 | 快 | 否 | 较低 |
| Park-Miller算法 | 通过 | 快 | 否 | 较低 |
| PCG算法 | 通过 | 快 | 否 | 中 |
| 原始延迟斐波那契算法 | 未通过 | 快 | 否 | 较低 |
| 改进型斐波那契算法 | 未通过 | 快 | 否 | 较低 |
| 原始线性反馈位移寄存器 | 基本通过 | 快 | 否 | 中 |
| Mersenne Twister算法 | 通过 | 快 | 否 | 较高 |
| Blum Blum Shub算法 | 通过 | 慢 | 是 | 中 |
| RtlGenRandom<br />(Windows CSPRNG) | 通过 | 慢 | 是 | / |

同时在测试过程中发现，本报告发现了，对于随机性较差的生成序列，NIST检测工具会提示如下的报错<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705863531847-5e5deaf6-8a74-4f32-8fba-bee15cb1241a.png#averageHue=%232a2a2a&clientId=u816e7609-1df0-4&from=paste&height=454&id=u68ce3df3&originHeight=614&originWidth=296&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=45842&status=done&style=none&taskId=ub5c4e966-94ff-41e3-bd0a-71f03d3b234&title=&width=219)<br />该报错提示随机序列的随机性较差，同时该条件下NIST检测工具将无法给出部分测试的测试结果。实际上，对于随机数生成器的生成序列，我们可以通过将该比特序列转化成图像的黑/白像素，从而可以在测试前直观的观察到生成序列的异常，从而重新评估生成器的实现质量。以上述实验数据为例，我们对比各算法生成序列的比特位图

1. PCG算法生成位图（左）vs 原始平方取中法生成位图（右）（相同缩放比例）

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705864091549-8ace69ab-c597-4881-92d6-9975e7828d37.png#averageHue=%237f7f7f&clientId=u816e7609-1df0-4&from=paste&height=326&id=u90a03b13&originHeight=440&originWidth=443&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=41861&status=done&style=none&taskId=ufa14ab35-868f-4f04-90b7-e372e8b66bf&title=&width=328.1481713293691)![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705864072422-5af16ce4-9ef8-4412-83cc-9bf9ecbc93dc.png#averageHue=%23c0c0c0&clientId=u816e7609-1df0-4&from=paste&height=327&id=u1aa51c49&originHeight=441&originWidth=442&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=34607&status=done&style=none&taskId=u9bfd7a8e-88c6-49cd-8dfe-436ca3b4b05&title=&width=327.4074305363006)<br />可以十分直观的看到，原始平方取中法生成的随机序列相当稀疏，这提示原始平方取中法的生成序列可能分布并不均匀，NIST检验测试结果最终验证了这一猜想

2. MT算法生成位图（左） vs 改进型斐波那契算法（右）（相同缩放比例）

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705864401657-dd9a36ee-0a24-40c1-83b3-240d976b89ca.png#averageHue=%237e7e7e&clientId=u816e7609-1df0-4&from=paste&height=324&id=ud35470cf&originHeight=438&originWidth=441&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=42003&status=done&style=none&taskId=ua1c1078e-4c25-4d9f-9f7e-ac5c40b2be8&title=&width=326.666689743232)![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705864457276-8ffe78d1-b0e3-47b4-8c4f-71099a8d3d46.png#averageHue=%237f7f7f&clientId=u816e7609-1df0-4&from=paste&height=324&id=u4a12b59a&originHeight=438&originWidth=438&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=41358&status=done&style=none&taskId=u6bc6a345-068b-42f6-840d-705c401790e&title=&width=324.44446736402637)<br />可以直观地看到，尽管生成位图密度相近，但改进型斐波那契序列中出现了较多的横纹，这提示生成序列可能会以偏离完全随机情况概率下的频率生成恒1序列，提示该伪随机数算法可能存在缺陷，可能无法通过块频率测试，重叠模板测试等统计学测试，NIST的检测结果最终证实了这一猜想。<br />通过提前生成比特位图观察，可以在不进行统计学检测的条件下较为直观的发现伪随机数生成器生成序列的异常，从而判定伪随机数生成器随机质量可能较差，从而可以避免进行不必要的NIST测试。
<a name="W1XY9"></a>
## 主流语言/操作系统伪随机数生成器分析
由于随机数所具备的随机性质被广泛应用于计算机领域的开发实践中，主流的编程语言与操作系统提供了内置的随机数生成器用于生成所需的随机数序列。本报告尝试调研了并收集了十种主流语言所提供内置伪随机数生成器，其调研结果汇总如下

| 语言 | 普通PRNG接口（类/库） | 实现算法 | CSPRNG接口（类/库） | 实现算法 |
| --- | --- | --- | --- | --- |
| C | rand() | LCG | / | / |
| Java | Random | LCG | java.security.SecureRandom | 依赖于操作系统 |
| C++ | random | MT, LFG | random_device | 依赖于操作系统 |
| Python | random | MT | secrets.rand(依赖于操作系统) | 依赖于操作系统 |
| Swift | arc4random()  | LCG | SecRandomCopyBytes | 依赖于Mac操作系统 |
| C# | Random | LCG | RandomNumberGenerator | 依赖于操作系统 |
| Go | math/rand | LCG | crypto/rand | 依赖于操作系统 |
| PHP | rand,mt_rand | LCG,MT | random_int() | 依赖于操作系统 |
| Rust | rand::rngs::smallRng | Xoshiro256++ | rand::Rng::OsRng/StdRng | 依赖于操作系统/ChaCha12 |
| JS | Math.random | LCG | crypto.getRandomValue | 依赖于操作系统 |

可以看到，多数主流语言提供了普通PRNG/CSPRNG两套不同的伪随机数生成器API，其中，普通PRNG主要使用LCG算法进行实现，而部分语言则使用LFSR类算法如MT算法进行实现，由前文实验可知，这两种算法所生成的伪随机数序列随机性较好，具备较高的生成质量。同时，由于LCG算法提出较早，其实现较为简单，因而受到了广泛的应用。同时，各语言所提供的CSPRNG主要调用了操作系统内置的随机数生成器，由前文分析可知，操作系统通过引入外部物理设备可以实现近似于真随机数生成器的生成效果，因而具有较强的对抗攻击能力，具备较好的密码学安全性。<br />同时，本报告调研了主流操作系统所提供的随机数生成器接口，调研结果汇总如下

| 语言 | 随机数生成器接口 | 实现算法 |
| --- | --- | --- |
| Windows | RtlGenRandom | SHA-1+熵源 |
| Linux | linux/random | 完全基于熵池 |
| Mac OS | arc4random_uniform | Fortuna（依赖熵源） |

可以看到，主流的操作系统的随机数生成接口均引入了外界物理设备作为熵源，由于熵源的不可预测性，这一实现能够有效提升生成算法的抗攻击性，从而提高算法的生成质量。<br />值得一提的是，对于早期的Windows2000操作系统，研究表明其内置的未公开算法的随机数生成器的具备较大缺陷[26]，可以通过单次窃取状态位攻击随机数生成器。进一步的研究表明，尽管Windows2000操作系统所使用的操作系统的随机数生成算法引入了熵源，但出于效率原因很少借助该熵源进行种子刷新。这提示通过引入外置熵源提高CSPRNG算法的安全性的操作效果依赖于熵源生成函数的定义与伪随机数生成器的内部实现，不当的算法实现很可能无法保证伪随机数生成器的安全质量。
<a name="xwbwY"></a>
## 伪随机生成器攻击尝试
<a name="UbYeI"></a>
### 基于数学理论的伪随机数攻击尝试
<a name="QuMgA"></a>
#### LCG攻击尝试
基于前文所描述的LCG理论我们可以发现，若已知LCG生成器的部分输出随机数，则有可能通过数论方式对LCG算法的后续生成序列进行预测。本报告对此进行探究，并依据理论分析实现对Java Random库的生成攻击，依据所已知的参数信息，可分为以下几种情况进行预测。
<a name="cqbuQ"></a>
##### LCG参数乘数、增量、与模数已知
若LCG参数乘数a，增量c与模数m均已知，则只需要知道当前伪随机数生成值X0，即可直接带入带入线性同余方程便可预测后续的伪随机数序列<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705847335576-eb83e496-5d6a-4446-9098-ae88530fbab5.png#averageHue=%23f4f4f4&clientId=u85e6a9a1-d608-4&from=paste&height=51&id=u358b7463&originHeight=87&originWidth=425&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=3806&status=done&style=none&taskId=u3b5331db-0fa5-456f-a819-d52b9f276f2&title=&width=248.8148193359375)<br />已知全部参数的情况实际上十分常见，绝大多数的编程语言与开源代码中均公开了其伪随机数生成器的实现方式与具体算法参数。同时，由于LCG算法需选取恰当的参数才能实现对于多数种子均生成较为良好的随机数序列，因此，LCG算法的推荐参数组往往较少且被公开，可以依此对未知参数的LCG生成器带入参数组进行猜测尝试
<a name="f9KGY"></a>
##### LCG参数增量未知
若给定LCG算法参数增量未知，则通过已知连续的两项随机数值即可预测后续的生成序列，其算法过程如下

1. 由于c小于m，故由原始伪随机数序列算法移项可的c的求解公式，公式如下

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705855795197-b186877c-387c-4bc8-8980-0c0ff2f167a8.png#averageHue=%23f0f0f0&clientId=u816e7609-1df0-4&from=paste&height=40&id=u9d631944&originHeight=66&originWidth=397&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=3645&status=done&style=none&taskId=u947b451c-5876-4c2b-9461-1ef0bd45fd3&title=&width=239.0740966796875)

2. 由上步骤获得了LCG算法的全部参数，同上文分析方法即可预测后续的生成序列
<a name="uKpDH"></a>
##### LCG参数增量与乘数未知
若给定LCG算法参数增量与乘数均未知，则通过已知连续的三项随机数值即可预测后续的生成序列，数学分析如下<br />对于三项连续随机数值Xi，Xi+1，Xi+2有如下关系<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705856097005-5eb5a6a8-f450-4d7b-8f4d-8cb7071d7158.png#averageHue=%23f1f1f1&clientId=u816e7609-1df0-4&from=paste&height=73&id=u4a4863b5&originHeight=122&originWidth=470&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=7483&status=done&style=none&taskId=uacc9d2b7-b4fe-4b0a-b617-f9c7df69b60&title=&width=282.1481628417969)<br />联立得<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705856181306-f0e7633f-8ea7-4f59-9115-f11c7ab4ed29.png#averageHue=%23f1f1f1&clientId=u816e7609-1df0-4&from=paste&height=42&id=u84a1e919&originHeight=67&originWidth=581&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=4258&status=done&style=none&taskId=u4398fc86-b42f-4185-abb7-0d4495e625d&title=&width=363.3703918457031)<br />故由于a为小于m的系数，移项可得a的求解公式<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705856277432-ff6b0812-a398-433e-b0ad-b10a50aca05f.png#averageHue=%23f2f2f2&clientId=u816e7609-1df0-4&from=paste&height=71&id=u8f9d72e1&originHeight=105&originWidth=404&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=4312&status=done&style=none&taskId=u2ea03f7e-aac5-44a0-9d37-840e886ed02&title=&width=271.25927734375)<br />后该问题转化为LCG参数增量未知条件下的求解问题，后续过程参见上文
<a name="taHnH"></a>
##### 针对Java Random类的攻击尝试
Java Random类属于上述分析中所有参数均已知的情形，通过查阅标准库源码可以得到相应系数与生成器具体实现方式。值得注意的是，在标准源码实现中，Java的一系列获取随机值的接口是通过截取当前48比特位随机数项的部分位数而获得的，如nextInt方法通过舍弃低16位而实现，因此，通过nextInt方法所获取到的值并非完整的随机数生成项。本报告尝试对此进行数学分析，并使用Java实现攻击算法<br />设所截断位数位低 t 位，随机数种子序列位{Xn}，每次调用nextInt所获得的随机数生成序列为{Sn}，输出时被截断舍去的序列位{Un}，则三序列各项具有如下关系<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705851031392-1153fb18-ccaf-4470-a661-8f8ff38b0a2b.png#averageHue=%23f2f2f2&clientId=u816e7609-1df0-4&from=paste&height=68&id=ubf018d89&originHeight=92&originWidth=500&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=5343&status=done&style=none&taskId=u81a52743-241f-4aeb-96b1-438387838fa&title=&width=370.37039653427667)<br />对于生成序列第i项与第i+1项，二者具有如下关系<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705850466055-b77b3e1b-facd-4158-8e6f-7de7054062ff.png#averageHue=%23ededed&clientId=u816e7609-1df0-4&from=paste&height=37&id=u146295a3&originHeight=53&originWidth=414&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=3488&status=done&style=none&taskId=uc484824a-2ea1-4bf7-bcd0-aa8586f9f5a&title=&width=286.66436767578125)<br />带入有![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705850743441-d7e48b57-400a-4245-8f2f-5bb8eb0fe951.png#averageHue=%23f0f0f0&clientId=u816e7609-1df0-4&from=paste&height=48&id=uc5823204&originHeight=71&originWidth=641&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=5882&status=done&style=none&taskId=u8a17aaec-7568-4884-9fbf-8c1472798cd&title=&width=429.8148498535156)<br />整理得![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705850812324-39877a42-8811-499f-9a1f-59d1a4562e62.png#averageHue=%23eeeeee&clientId=u816e7609-1df0-4&from=paste&height=46&id=ue4e8e252&originHeight=62&originWidth=626&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=5579&status=done&style=none&taskId=u288066d0-ae76-4075-93cc-b1b41f3f039&title=&width=463.70373646091434)<br />上式中，等式左侧可依据参数与所提供的连续两项随机数生成序列求出具体数值，则只需求解符合该等式的未知数元组（Ui,Ui+1），该元组解需满足上述中对U的取值限制关系<br />基于该公式可以设计对于nextInt方法的攻击算法，将上述公式整理得如下表达式<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705851152665-0b98bf28-fa85-453a-92f5-928335795b03.png#averageHue=%23efefef&clientId=u816e7609-1df0-4&from=paste&height=41&id=uc1e0aaa6&originHeight=67&originWidth=637&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=5430&status=done&style=none&taskId=ufc045aaf-fce7-409a-8981-7cb9aaae5a4&title=&width=387.85186767578125)<br />遍历所有Ui的可能取值直至Ui+1符合取值限制，此时，我们找到了未知数元组（Ui,Ui+1）的解，从而成功复原了两项随机数种子项的完整数值。由于对于nextInt方法，其所需遍历的可能取值次数不超过216，因此该算法能够较快求得生成器内部的种子数值。<br />上述算法的主体部分java代码思想大致如下
```java
    private JavaRandomAttacker(long s0, long s1, int bitWidth) {
        D = 1L << LEN - bitWidth;
        long dif = (((a * s0 - s1) % m) * (D % m) + c) % m;
        long u1 = guessPair(dif, D);
        seed = s1 * D + u1;
    }

    private static long guessPair(long dif, long max) {
        for (int i = 0; i < max; i++) {
            long res = (dif + a * i) % m;
            if (res < max) return res;
        }
        throw new RuntimeException("err!");
    }
```
对上述攻击算法效果进行实验，实验结果如下，可以看到，上述攻击器正确预测了随机数生成器的后续序列<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705849231461-36c61f07-b5b1-446c-8078-0b7491748f76.png#averageHue=%23f4f1ee&clientId=u85e6a9a1-d608-4&from=paste&height=244&id=u71b185f9&originHeight=329&originWidth=502&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=41526&status=done&style=none&taskId=u4e99b0cb-54ec-4b7a-b3e5-ff95b9062cc&title=&width=371.85187812041374)<br />对上述攻击算法进行100000次检验，检验其是否能够正确预测后续所生成序列前100项，可以看到上述算法成功通过了完整的攻击实验<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/34413599/1705854755083-c2c2b898-f238-4161-a224-2f3d2b2e8257.png#averageHue=%23f9f8f7&clientId=u816e7609-1df0-4&from=paste&height=395&id=uaa1640c2&originHeight=643&originWidth=901&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=78246&status=done&style=none&taskId=uaecbc2af-f12b-4e9f-b5a5-64ef01c8bc1&title=&width=553.4028015136719)<br />可以看到，仅仅通过获得两项连续的随机数种子的片段（如所获取的nextInt值），我们便可推断后续的全部生成序列，更为糟糕的是，在Java Random类库的API实现中，nextLong与nextDouble的实现正是由两个连续的随机数种子片段所拼接而成，这意味着只需已知两个接口的任意一个输出便可预测后续全部的生成序列，这提示Java Random类所产生的随机数不应用于任何已知随机值可能破坏程序安全性与有效性的场景。
<a name="uXUP1"></a>
## 伪随机数生成器的应用与展望
由于各领域对随机数生成的迫切需要，自伪随机数生成器诞生以来，其便被广泛应用于各种领域。报告综合相关资料尝试对此进行简要地阐述，并展望伪随机数生成器的未来发展
<a name="QrgnM"></a>
### 伪随机数生成器的密码学应用
伪随机数生成器最为重要的应用之一便是密码学场景。作为密码学领域的基础性工具，大多数密码原语的安全性都依赖于高质量的不可预测的随机数，伪随机数生成器在该领域具备广泛的应用，其中主要包括[27]：

1. 加密算法：伪随机数生成器被应用于加密算法的实现，如El Gamal等加密算法使用随机数提高的算法的安全性，部分加密算法则依赖于密码学安全的伪随机数生成器以保障算法的可靠性与安全性。同时，伪随机数生成器也被应用于密钥派生与数字签名之中。
2. 随机填充：伪随机数生成器同样被应用于对序列的随机填充常见，如密码加盐或信息混淆中，往往采用需要伪随机数生成器生成随机序列进行填充操作。
<a name="vijiy"></a>
### 伪随机数生成器的模拟应用
伪随机数生成器被广泛应用于计算机模拟过程中，主要包括：

1. 蒙特卡洛类算法：蒙特卡洛类算法依赖于随机数而实现，需要提供能够生成具有较好统计学随机性质随机序列的生成器，这类算法被广泛应用于工程开发与实践中
2. 仿真类算法：在仿真领域，如交通流量模拟、人口统计模拟或生态系统模拟，PRNGs用于生成符合特定分布的数据，以模拟现实世界中的随机事件。
3. 抽样统计操作：抽样统计操作通过从一个大数据集中抽取代表性样本为了进行统计分析，随机性较好的PRNG可以较为有效的选取样本点，从而确保样本具备统计学需求的随心。
<a name="mSYdN"></a>
### 伪随机数生成器的程序开发应用
随机数生成器被广泛应用于实际领域的软件开发中，如游戏领域常使用的随机洗牌，验证码生成，抽奖等功能的实现中。与认为CSPRNG仅适用于密码学领域的误区不同的是，程序开发领域往往也需要使用具备对抗攻击性的CSPRNG，如上述所提到的场景中，一旦业务过程暴露了一定的生成器参数（如往往不可避免地提供给用户的随机结果），该业务的随机序列就有可能被预测，从而带来严重的安全隐患。同时对于一些实现不佳的项目，服务器内的随机数生成器可能仅仅在如服务器重启等特定时刻才进行初始种子重置，因而生成周期较短的，对抗攻击性较弱的伪随机数生成器可能会更容易受到攻击，也更容易造成广泛且长期的负面风险，因此，程序开发领域也需要对所使用的随机场景进行评估，综合效率考虑是否使用CSPRNG级别的密码生成器，避免伪随机数生成器受到攻击造成的损失。
<a name="rjUML"></a>
### 展望随机数生成器的发展
在计算机科学领域高速发展的背景下，随机数算法的发展已日渐成熟，逐渐研究并提出了一系列具备可靠随机性与安全性的随机数生成算法，在未来，随机数生成器将被进一步广泛使用，对现有的随机数生成器的改进与创新可能围绕提供更加高效的PRNG（尤其是CSPRNG）算法，进一步引入物理过程（如量子过程）提高其随机性与安全性，同时，开发者可能将进一步采取措施，避免不佳实践造成PRNG生成可预测的随机序列，以及采用对抗随机数后门攻击的密码算法[28]以避免后门攻击。
<a name="fqIbq"></a>
# 参考资料
[1]Salil Vadhan, Pseudorandomness [https://people.seas.harvard.edu/~salil/pseudorandomness/introduction.pdf](https://people.seas.harvard.edu/~salil/pseudorandomness/introduction.pdf)<br />[2]Zhouhui Lian,Intelligent Optimization Methods<br />[https://www.icst.pku.edu.cn/zlian/docs/20181023154331943266.pdf](https://www.icst.pku.edu.cn/zlian/docs/20181023154331943266.pdf)<br />[3] Schindler, Werner. Functionality Classes and Evaluation Methodology for Deterministic Random Number Generators (PDF). Anwendungshinweise und Interpretationen (AIS). Bundesamt für Sicherheit in der Informationstechnik: 5–11. 2 December 1999 [19 August 2013].<br />[4] WolfSSL 2021.7, True Random vs. Pseudorandom Number Generation<br /> [https://www.wolfssl.com/true-random-vs-pseudorandom-number-generation/](https://www.wolfssl.com/true-random-vs-pseudorandom-number-generation/)<br />[5] 李贤平（复旦大学）．概率论基础（第三版）．北京．高等教育出版社．2010<br />[6] 国家密码管理局, GM/T 0005-2021 随机性检测规范<br />[7] Andrew Rukhin (NIST), Juan Soto (NIST), James Nechvatal (NIST), Miles Smid (NIST), Elaine Barker (NIST), Stefan Leigh (NIST), Mark Levenson (NIST), Mark Vangel (NIST), David Banks (NIST), N. Heckert (NIST), James Dray (NIST), San Vo (NIST), Lawrence Bassham (NIST), A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications, National Institute of Standards and Technology(NIST)<br />[8] Binomial Test, UTEXAS<br />[https://sites.utexas.edu/sos/guided/inferential/categorical/univariate/binomial/](https://sites.utexas.edu/sos/guided/inferential/categorical/univariate/binomial/)<br />[9] Song-Ju Kim, Ken Umeno, Corrections of the NIST Statistical Test Suite for Randomness, 2004<br />[10]  Pareschi, F., Rovatti, R., & Setti, G, On Statistical Tests for Randomness included in the NIST SP800-22 test suite and based on the Binomial Distribution  <br />[11] F. Pareschi, R. Rovatti, and G. Setti, Second-level NIST randomness tests for improving test reliability.<br />[12] J. Massey, Shift-register synthesis and BCH decoding, IEEE Transactions on Information Theory<br />[13] NIST SP 800-22: Download Documentation and Software<br />[14] John von Neumann, Various Techniques Used in Connection With Random Digits<br />[15] Bernard Widynski, Middle-Square Weyl Sequence RNG<br />[16] Thhomson, W.E. A Modified Congruence Method of Generating Pseudo-random Number<br />[17] Donald Knuth, The Art of Computer Programming<br />[18] Marsaglia, George, Random Numbers Fall Mainly in the Planes<br />[19] Park, Stephen K. Miller, Keith W. , Random Number Generators: Good Ones Are Hard To Find<br />[20] O'Neill, Melissa E., PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation.<br />[21] George Marsaglia, Comp.Sci. and Statistics: Symposium on the Interface<br />[22] Golomb, Solomon W., Shift register sequences. Laguna Hills, Calif.: Aegean Park Press.<br />[23] Matsumoto, M.; Nishimura, T.  Mersenne twister: a 623-dimensionally equidistributed uniform pseudo-random number generator<br />[24]Blum, L.; Blum, M.; Shub, M. (1986). A Simple Unpredictable Pseudo-Random Number Generator<br />[25]RtlGenRandom函数, Microsoft Document<br />[https://learn.microsoft.com/zh-cn/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom?redirectedfrom=MSDN](https://learn.microsoft.com/zh-cn/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom?redirectedfrom=MSDN)<br />[26]Dorrendorf, Leo; Zvi Gutterman; Benny Pinkas. Cryptanalysis of the Random Number Generator of the Windows Operating System<br />[27] Andrea Rock, Salzburg, Marz,Pseudorandom Number Generators for Cryptographic Applications<br />[28] 康步荣, 张磊, 张蕊, 孟欣宇, 陈桐. 抗随机数后门攻击的密码算法
